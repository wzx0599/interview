+ C++中指针与引用的区别？([参考链接](https://www.cnblogs.com/gxcdream/p/4805612.html))

  + 本质上，引用是别名，而指针是地址。
  + 指针在运行的时候可以改变其所指向的值，引用一旦和某个对象绑定后就不可改变。
  + 理论上，指针的级数没有限制，但是引用只能有一级。
  + *不存在指向空值的引用；而指针可以指向空值。
  + *程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名和变量所对应的地址，指针变量在符号表上对应的地址值为指针变量的地址，而引用在符号表上对应的地址是引用对象的地址值。符号表生成后就不会再改变，因此指针可以改变指向的对象，而引用不可以改变。

+ 指针传递与引用传递

  函数传递参数主要有三种方式：值传递，指针传递和引用传递。

  + 值传递：值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数中实参变量的值。
  + 指针传递：指针传递参数本质上还是一种值传递的方式。不同的是，虽然指针本身经过值传递，在函数中是原始的一份拷贝，但是拷贝前后指针的内存空间指向并为发生改变，所以在函数中对指针所指变量的改变会体现在变量中。
  + 引用传递：引用传递后，被调函数对参数的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。因此，被调函数对形参做的任何操作都会影响主调函数中的实参变量。

  简而言之，值传递中被调函数对形参的改变不会体现在实参上；指针传递和引用传递中被调函数对形参的改变会体现在实参上，但是二者实现的方式不同，指针传递中指针本身依旧是值传递，而引用传递中传递了实参的别名，可认为是实参本身。

+ 指针常量和常量指针的区别？顶层const和底层const之间的区别？this指针是顶层const还是底层const？

  

+ 关键字```const```和```constexpr```之间的区别是什么？([参考链接](https://www.cnblogs.com/fortunely/p/14550145.html))

  ```const```指的是常量，但是并未限定是编译期常量还是运行期常量；```constexpr```限定了编译期常量。

  + 修饰变量：```const```修饰变量，表示一个变量无法改变，但初值并不确定，不能在编译阶段决定；```consexpr```侧重变量初值在编译期确定且无法修改。如果认定变量是一个常量表达式，就把它声明为```constexpr```。
  + 修饰指针：```const```修饰指针分为两种情况：顶层```const```和底层```const```。顶层```const```代表指针变量自身是无法改变的；底层```const```代表指针所指对象无法改变。```constexpr```修饰指针仅对指针有效，与所指对象无关。
  + 修饰函数：`const`修饰成员函数，通常称为`const`函数，表示该函数不会修改类的状态（即不会通过任何方式修改类数据成员）。另外，`const`类对象，只能调用`const`函数，确保不会修改类的数据成员。`constexpr`无法修饰成员函数，只能作为函数返回值类型，表明该函数返回的是一个编译期可确定的常量。

+ 重载和重写之间的区别是什么？

  + 重载overload，函数名相同，参数列表不同，重载只能在类的内部存在，并且不能依靠返回类型来判断。
  + 重写override，子类重新定义父类中由相同名称和参数的虚函数。函数签名相同，但是具体的内部实现不同，主要在继承关系中体现。
  + *重定义redefining，子类重新定义父类中有相同名称的非虚函数，参数列表可以不同。

+ 为什么构造函数不可以是虚函数？

  虚函数的实体对应一个位于虚函数表中的函数指针，而虚函数表需要位于每个对象存储空间中的虚表指针来访问。如果构造函数是虚的，那就需要通过虚函数表来访问，但是此时对象还没有进行实例化，没有对应的内存空间和虚表指针。

+ 为什么析构函数需要是虚函数？为什么默认的析构函数不是虚函数？([参考链接](https://blog.csdn.net/qq_42247231/article/details/105109709))

  + 对于派生类的对象，其正确的资源释放方式应该是先调用派生类的析构函数再调用基类的析构函数。而如果基类的析构函数不是虚函数，我们删除一个基类指针指向派生类的实例时，就会出现只能清理派生类从基类中继承的资源而无法清理派生类中独有的资源，这样就可能会造成内存泄漏等情况的发生。
  + 虚函数不同于普通的成员函数，当类中有成员函数时，类会自动进行一些额外的工作。这些工作包括生成虚函数表和虚表指针。这样一来，就会占用额外的内存，当我们定义的类不需要被其他类继承时，这种内存开销是浪费的。因此，系统默认我我们不会将我们定义的类作为基类使用，那么就会将默认的析构函数定义为非虚函数。

+ 虚函数和纯虚函数的区别是什么？([参考链接](https://www.cnblogs.com/inception6-lxc/p/8597326.html))

  + 虚函数和纯虚函数可以被定义在同一个类中，含有纯虚函数的类被称为抽象类，而只包含虚函数的类不能被称为抽象类。
  + 虚函数可以被直接调用，也可以被派生类重写后以多态的形式调用，而纯虚函数必须在派生类中实现改函数才可以使用，因为纯虚函数在基类中只有声明而没有定义。
  + 虚函数和纯虚函数通常存在于抽象基类中，被继承的派生类重写，目的是提供一个统一的接口。
  + 在虚函数和纯虚函数的定义中不能有```static```关键字标识，被```static```修饰的函数在编译期要求前期绑定，而虚函数是动态绑定的。
  + 虚函数必须被实现，如果不实现，编译器将会报错。
  + 实现了纯虚函数的派生类中，该纯虚函数在派生类中就变成了虚函数，那么派生类的派生类可以对其进行重写。
  + *多态是指相同的对象收到不同消息或者不同对象收到相同消息时产生不同的实现动作。编译期多态是通过重载函数实现的，运行期多态是通过虚函数实现的。

+ 虚函数的实现机制是什么？

  虚函数是C++中实现多态特性的一种重要方式。虚函数的实现依赖虚函数表和虚表指针。

  + 从位置和产生时机来看，对于一个含有虚函数的类，在编译期就会生成一个虚函数表，被该类所有实例共享。

+ 关键字```static```的作用是什么？([参考链接](https://blog.csdn.net/zzyzgg/article/details/89842744))

  + 修饰局部变量：```static```修饰局部变量时，被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期和程序相同，在main函数之前被初始化，在程序退出时销毁。
  + 修饰全局变量：全局变量本来就存储在静态区，因此```static```并不能改变其存储位置。但是，```static```限制了其链接属性。被```static```修饰的全局变量只能被包含该定义的文件访问，改变了变量的作用域。
  + 修饰函数：```static```修饰函数使得函数只能在包含该函数定义的文件中被调用。对于静态函数，声明和定义需要放在同一个文件夹中。
  + 修饰成员变量：用```static```修饰类的成员会使其成为类的全局变量，被类的所有对象共享，包括派生类的对象，所有的对象都只维持同一个实例。因此，```static```成员必须要在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用```const```修饰```static```承运在类内初始化。
  + 修饰成员函数：用```static```修饰成员函数，使这个类只存在这一个函数实体，所有对象共享该函数，不包含```this```指针，因而只能访问类的```static```成员变量。静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。注意，不可以同时用```const```和```static```修饰成员函数。

+ 大端模式和小端模式之间的区别([参考链接](https://blog.csdn.net/ycc541/article/details/44494547))

  + ```Little-Endian```是低字节放内存的低地址，高字节放内存的高地址。
  + ```Big-Endian```是高字节放内存的低地址，低字节放内存的高地址。

+ 介绍C++对象内存模型

  

+ new和malloc之间的区别

  

+ 拷贝控制——拷贝构造、拷贝赋值、转移构造、转移赋值、析构

  

+ 为什么不可以同时用```const```和```static```修饰成员函数？

  C++编译器在实现```const```的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数```const this*```。但当一个成员为```static```的时候，该函数是没有```this```指针。也就是说此时```const```与```static```在用法和语意上是冲突的。